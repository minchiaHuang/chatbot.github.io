# 004-lesson-cosine-similarity-visual: 餘弦相似度視覺化解釋

## 把向量想像成箭頭

想像每部電影和每個問題都是一個**箭頭**：

- 箭頭的方向 = 電影/問題的「特性」
- 箭頭越相似 = 電影越符合問題

```
科幻電影向量:     ➡️ (指向科幻方向)
動作電影向量:     ↗️ (指向動作方向)
愛情電影向量:     ⬆️ (指向愛情方向)

用戶問題「科幻電影」: ➡️ (也指向科幻方向)
```

## 餘弦相似度 = 測量箭頭夾角

```
夾角小 = 相似度高     夾角大 = 相似度低
   ➡️                    ➡️
   ➡️  (完全重疊)         ⬆️  (垂直)
  相似度 = 1            相似度 = 0
```

## 數學步驟解釋

### 1. 點積 (Dot Product)

```javascript
dot += vecA[i] * vecB[i];
```

**自然語言**: 計算兩個箭頭有多「同方向」

- 如果兩個數字都是正數 → 貢獻正值
- 如果一正一負 → 貢獻負值

### 2. 計算長度 (Norm)

```javascript
normA += vecA[i] * vecA[i]; // A向量的長度平方
normB += vecB[i] * vecB[i]; // B向量的長度平方
```

**自然語言**: 計算每個箭頭有多「長」

### 3. 標準化 (Normalization)

```javascript
return dot / (Math.sqrt(normA) * Math.sqrt(normB));
```

**自然語言**:

- 不管箭頭多長，只看方向
- 把結果調整到 -1 到 1 之間

## 實際範例

假設我們有簡化的 3 維向量：

```
電影A「星際大戰」= [0.9, 0.1, 0.0]  (高科幻，低愛情，無恐怖)
電影B「鐵達尼號」= [0.0, 0.9, 0.1]  (無科幻，高愛情，低恐怖)
問題「科幻電影」 = [1.0, 0.0, 0.0]  (純科幻)

計算問題 vs 電影A：
dot = 1.0×0.9 + 0.0×0.1 + 0.0×0.0 = 0.9
normA = √(1.0² + 0.0² + 0.0²) = 1.0
normB = √(0.9² + 0.1² + 0.0²) = 0.905
相似度 = 0.9 / (1.0 × 0.905) = 0.99  ← 很相似！

計算問題 vs 電影B：
dot = 1.0×0.0 + 0.0×0.9 + 0.0×0.1 = 0.0
相似度 = 0.0 / ... = 0.0  ← 完全不相似！
```

## 為什麼要用餘弦相似度？

✅ **優點**:

- 專注於「方向」不受「大小」影響
- 結果容易理解 (0-1 之間)
- 適合比較文字特徵

❌ **如果不用餘弦相似度**:

- 長文本會比短文本「看起來更相似」
- 無法公平比較不同長度的描述
